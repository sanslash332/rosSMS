import rospy
import math
from tf.transformations import euler_from_quaternion
from nav_msgs.msg import Odometry
from geometry_msgs.msg import Point
from geometry_msgs.msg import Quaternion
from geometry_msgs.msg import Twist


class Turtlebot_Wheels:
	def __init__(self):
		self.odom_sub = rospy.Subscriber('/odom',Odometry,self.position_recv)
	    	self.nav_pub = rospy.Publisher('/cmd_vel_mux/input/navi', Twist)
		rospy.init_node('Wheels', anonymous=True)	
		self.rate = rospy.Rate(10)
		self.posx = 0
		self.posy = 0
		self.ang = 0
		self.Kpx = 0.1
		self.Kpa = 0.2
        
	def position_recv(self, data):
		pos = data.pose.pose.position
		quat = data.pose.pose.orientation
		self.posx = pos.x
		self.posy = pos.y
		self.ang = euler_from_quaternion([quat.x, quat.y, quat.z, quat.w])[2]

	def move_straight(self, distance, vel):
		data = Twist()
		posx_init = self.posx 
		posy_init = self.posy
		dist = 0
		data.linear.x = vel
		while(dist < distance):
			x = self.posx - posx_init
			y = self.posy - posy_init	
			dist = math.sqrt(math.pow(x, 2) + math.pow(y, 2)) 
			self.nav_pub.publish(data) 			
			self.rate.sleep()
		data = Twist()		
		self.nav_pub.publish(data)
		
	def move_rotate(self, angle, vel): 
		data = Twist()
		ang_init = self.ang
		ang = 0
		data.angular.z = vel
		while(ang < angle):
			self.nav_pub.publish(data)
			ang = self.ang - ang_init
			self.rate.sleep()
		data = Twist()		
		self.nav_pub.publish(data)

	def move_straight2(self, distance):
		data = Twist()
		posx_init = self.posx
		posy_init = self.posy
		dist = 0
		while(dist < distance):
			x = self.posx - posx_init
			y = self.posy - posy_init
			dist = math.sqrt(math.pow(x, 2) + math.pow(y, 2))
			velx = self.kp * dist
			if(vel > 0.5):
				vel = 0.5
			data.linear.x = vel
			self.nav_pub.publish(data)
			self.rate.sleep()
		data = Twist()		
		self.nav_pub.publish(data)

	def move_rotate2(self, angle):
		data = Twist()
		ang_init = self.ang
		angA = 0
		while(angA < angle):
			angA = self.ang - ang_init
			rospy.loginfo("AngA is" + str(angA))
			vel = self.Kpa*(angle - angA)
			rospy.loginfo("Vel is" + str(vel))
			data.angular.z = vel
			self.nav_pub.publish(data)
			self.rate.sleep()
		data = Twist()		
		self.nav_pub.publish(data)
def main():
	TBW = Turtlebot_Wheels()
	TBW.move_rotate2(math.pi/2)
	rospy.spin()

if __name__ == '__main__':
	try:
		main()
	except rospy.ROSInterruptException:
		pass
